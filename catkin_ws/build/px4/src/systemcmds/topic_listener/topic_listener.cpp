

/****************************************************************************
 *
 *   Copyright (c) 2015 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file topic_listener.cpp
 *
 * Autogenerated by Tools/generate_listener.py
 *
 * Tool for listening to topics when running flight stack on linux.
 */

#include <drivers/drv_hrt.h>
#include <px4_middleware.h>
#include <px4_app.h>
#include <px4_config.h>
#include <uORB/uORB.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifndef PRIu64
#define PRIu64 "llu"
#endif

#ifndef PRId64
#define PRId64 "lld"
#endif


#include <uORB/topics/sensor_baro.h>
#include <uORB/topics/mission.h>
#include <uORB/topics/transponder_report.h>
#include <uORB/topics/actuator_controls.h>
#include <uORB/topics/rate_ctrl_status.h>
#include <uORB/topics/power_button_state.h>
#include <uORB/topics/mount_orientation.h>
#include <uORB/topics/subsystem_info.h>
#include <uORB/topics/uavcan_parameter_value.h>
#include <uORB/topics/log_message.h>
#include <uORB/topics/actuator_outputs.h>
#include <uORB/topics/esc_report.h>
#include <uORB/topics/test_motor.h>
#include <uORB/topics/esc_status.h>
#include <uORB/topics/differential_pressure.h>
#include <uORB/topics/adc_report.h>
#include <uORB/topics/sensor_selection.h>
#include <uORB/topics/cpuload.h>
#include <uORB/topics/rc_channels.h>
#include <uORB/topics/sensor_bias.h>
#include <uORB/topics/vehicle_status_flags.h>
#include <uORB/topics/vehicle_command.h>
#include <uORB/topics/camera_capture.h>
#include <uORB/topics/obstacle_distance.h>
#include <uORB/topics/debug_key_value.h>
#include <uORB/topics/airspeed.h>
#include <uORB/topics/safety.h>
#include <uORB/topics/camera_trigger.h>
#include <uORB/topics/landing_target_pose.h>
#include <uORB/topics/vehicle_attitude_setpoint.h>
#include <uORB/topics/telemetry_status.h>
#include <uORB/topics/multirotor_motor_limits.h>
#include <uORB/topics/sensor_accel.h>
#include <uORB/topics/debug_value.h>
#include <uORB/topics/vehicle_global_position.h>
#include <uORB/topics/servorail_status.h>
#include <uORB/topics/actuator_armed.h>
#include <uORB/topics/vehicle_command_ack.h>
#include <uORB/topics/estimator_status.h>
#include <uORB/topics/vehicle_control_mode.h>
#include <uORB/topics/debug_vect.h>
#include <uORB/topics/task_stack_info.h>
#include <uORB/topics/vehicle_status.h>
#include <uORB/topics/system_power.h>
#include <uORB/topics/sensor_combined.h>
#include <uORB/topics/vehicle_rates_setpoint.h>
#include <uORB/topics/wind_estimate.h>
#include <uORB/topics/tecs_status.h>
#include <uORB/topics/sensor_correction.h>
#include <uORB/topics/optical_flow.h>
#include <uORB/topics/irlock_report.h>
#include <uORB/topics/collision_report.h>
#include <uORB/topics/led_control.h>
#include <uORB/topics/ekf2_innovations.h>
#include <uORB/topics/uavcan_parameter_request.h>
#include <uORB/topics/gps_dump.h>
#include <uORB/topics/rc_parameter_map.h>
#include <uORB/topics/parameter_update.h>
#include <uORB/topics/geofence_result.h>
#include <uORB/topics/vehicle_attitude.h>
#include <uORB/topics/att_pos_mocap.h>
#include <uORB/topics/battery_status.h>
#include <uORB/topics/vehicle_land_detected.h>
#include <uORB/topics/time_offset.h>
#include <uORB/topics/mission_result.h>
#include <uORB/topics/tune_control.h>
#include <uORB/topics/satellite_info.h>
#include <uORB/topics/mavlink_log.h>
#include <uORB/topics/qshell_req.h>
#include <uORB/topics/vehicle_local_position.h>
#include <uORB/topics/manual_control_setpoint.h>
#include <uORB/topics/home_position.h>
#include <uORB/topics/fw_pos_ctrl_status.h>
#include <uORB/topics/sensor_preflight.h>
#include <uORB/topics/gps_inject_data.h>
#include <uORB/topics/follow_target.h>
#include <uORB/topics/ulog_stream_ack.h>
#include <uORB/topics/lqr_controls.h>
#include <uORB/topics/sensor_gyro.h>
#include <uORB/topics/commander_state.h>
#include <uORB/topics/ulog_stream.h>
#include <uORB/topics/ekf2_timestamps.h>
#include <uORB/topics/landing_target_innovations.h>
#include <uORB/topics/distance_sensor.h>
#include <uORB/topics/offboard_control_mode.h>
#include <uORB/topics/vehicle_gps_position.h>
#include <uORB/topics/vtol_vehicle_status.h>
#include <uORB/topics/actuator_direct.h>
#include <uORB/topics/input_rc.h>
#include <uORB/topics/vehicle_roi.h>
#include <uORB/topics/sensor_mag.h>

extern "C" __EXPORT int listener_main(int argc, char *argv[]);

static bool check_timeout(const hrt_abstime& time) {
    if (hrt_elapsed_time(&time) > 2*1000*1000) {
		printf("Waited for 2 seconds without a message. Giving up.\n");
        return true;
    }
    return false;
}

void listen_parameter_update(unsigned num_msgs, unsigned topic_instance);
void listen_vtol_vehicle_status(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_bias(unsigned num_msgs, unsigned topic_instance);
void listen_rc_parameter_map(unsigned num_msgs, unsigned topic_instance);
void listen_ekf2_timestamps(unsigned num_msgs, unsigned topic_instance);
void listen_collision_report(unsigned num_msgs, unsigned topic_instance);
void listen_adc_report(unsigned num_msgs, unsigned topic_instance);
void listen_att_pos_mocap(unsigned num_msgs, unsigned topic_instance);
void listen_follow_target(unsigned num_msgs, unsigned topic_instance);
void listen_rc_channels(unsigned num_msgs, unsigned topic_instance);
void listen_multirotor_motor_limits(unsigned num_msgs, unsigned topic_instance);
void listen_servorail_status(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_global_position(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_global_position_groundtruth(unsigned num_msgs, unsigned topic_instance);
void listen_differential_pressure(unsigned num_msgs, unsigned topic_instance);
void listen_qshell_req(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_correction(unsigned num_msgs, unsigned topic_instance);
void listen_landing_target_innovations(unsigned num_msgs, unsigned topic_instance);
void listen_tecs_status(unsigned num_msgs, unsigned topic_instance);
void listen_rate_ctrl_status(unsigned num_msgs, unsigned topic_instance);
void listen_led_control(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_gps_position(unsigned num_msgs, unsigned topic_instance);
void listen_offboard_control_mode(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_status(unsigned num_msgs, unsigned topic_instance);
void listen_time_offset(unsigned num_msgs, unsigned topic_instance);
void listen_system_power(unsigned num_msgs, unsigned topic_instance);
void listen_safety(unsigned num_msgs, unsigned topic_instance);
void listen_ulog_stream(unsigned num_msgs, unsigned topic_instance);
void listen_ulog_stream_ack(unsigned num_msgs, unsigned topic_instance);
void listen_gps_inject_data(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_preflight(unsigned num_msgs, unsigned topic_instance);
void listen_log_message(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_outputs(unsigned num_msgs, unsigned topic_instance);
void listen_debug_value(unsigned num_msgs, unsigned topic_instance);
void listen_uavcan_parameter_value(unsigned num_msgs, unsigned topic_instance);
void listen_wind_estimate(unsigned num_msgs, unsigned topic_instance);
void listen_power_button_state(unsigned num_msgs, unsigned topic_instance);
void listen_home_position(unsigned num_msgs, unsigned topic_instance);
void listen_optical_flow(unsigned num_msgs, unsigned topic_instance);
void listen_ekf2_innovations(unsigned num_msgs, unsigned topic_instance);
void listen_esc_report(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_attitude_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_mc_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_fw_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_rates_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_mc_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_fw_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_airspeed(unsigned num_msgs, unsigned topic_instance);
void listen_transponder_report(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_command(unsigned num_msgs, unsigned topic_instance);
void listen_cpuload(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_attitude(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_attitude_groundtruth(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_vision_attitude(unsigned num_msgs, unsigned topic_instance);
void listen_debug_vect(unsigned num_msgs, unsigned topic_instance);
void listen_manual_control_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_tune_control(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_direct(unsigned num_msgs, unsigned topic_instance);
void listen_camera_capture(unsigned num_msgs, unsigned topic_instance);
void listen_geofence_result(unsigned num_msgs, unsigned topic_instance);
void listen_mission(unsigned num_msgs, unsigned topic_instance);
void listen_battery_status(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_control_mode(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_0(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_1(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_2(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_3(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_virtual_fw(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_virtual_mc(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_status_flags(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_combined(unsigned num_msgs, unsigned topic_instance);
void listen_esc_status(unsigned num_msgs, unsigned topic_instance);
void listen_test_motor(unsigned num_msgs, unsigned topic_instance);
void listen_mission_result(unsigned num_msgs, unsigned topic_instance);
void listen_gps_dump(unsigned num_msgs, unsigned topic_instance);
void listen_mavlink_log(unsigned num_msgs, unsigned topic_instance);
void listen_fw_pos_ctrl_status(unsigned num_msgs, unsigned topic_instance);
void listen_subsystem_info(unsigned num_msgs, unsigned topic_instance);
void listen_mount_orientation(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_command_ack(unsigned num_msgs, unsigned topic_instance);
void listen_input_rc(unsigned num_msgs, unsigned topic_instance);
void listen_landing_target_pose(unsigned num_msgs, unsigned topic_instance);
void listen_debug_key_value(unsigned num_msgs, unsigned topic_instance);
void listen_distance_sensor(unsigned num_msgs, unsigned topic_instance);
void listen_estimator_status(unsigned num_msgs, unsigned topic_instance);
void listen_obstacle_distance(unsigned num_msgs, unsigned topic_instance);
void listen_lqr_controls(unsigned num_msgs, unsigned topic_instance);
void listen_telemetry_status(unsigned num_msgs, unsigned topic_instance);
void listen_irlock_report(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_mag(unsigned num_msgs, unsigned topic_instance);
void listen_uavcan_parameter_request(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_land_detected(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_selection(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_baro(unsigned num_msgs, unsigned topic_instance);
void listen_satellite_info(unsigned num_msgs, unsigned topic_instance);
void listen_task_stack_info(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_gyro(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_local_position(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_local_position_groundtruth(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_vision_position(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_accel(unsigned num_msgs, unsigned topic_instance);
void listen_camera_trigger(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_armed(unsigned num_msgs, unsigned topic_instance);
void listen_commander_state(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_roi(unsigned num_msgs, unsigned topic_instance);


int listener_main(int argc, char *argv[]) {
	if(argc < 2) {
		printf("need at least two arguments: topic name. [optional number of messages to print] [optional instance]\n");
		return 1;
	}

	unsigned num_msgs = (argc > 2) ? atoi(argv[2]) : 1;
	unsigned topic_instance = (argc > 3) ? atoi(argv[3]) : 0;

	if (strncmp(argv[1],"parameter_update",50) == 0) {
		listen_parameter_update(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vtol_vehicle_status",50) == 0) {
		listen_vtol_vehicle_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_bias",50) == 0) {
		listen_sensor_bias(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"rc_parameter_map",50) == 0) {
		listen_rc_parameter_map(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"ekf2_timestamps",50) == 0) {
		listen_ekf2_timestamps(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"collision_report",50) == 0) {
		listen_collision_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"adc_report",50) == 0) {
		listen_adc_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"att_pos_mocap",50) == 0) {
		listen_att_pos_mocap(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"follow_target",50) == 0) {
		listen_follow_target(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"rc_channels",50) == 0) {
		listen_rc_channels(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"multirotor_motor_limits",50) == 0) {
		listen_multirotor_motor_limits(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"servorail_status",50) == 0) {
		listen_servorail_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_global_position",50) == 0) {
		listen_vehicle_global_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_global_position_groundtruth",50) == 0) {
		listen_vehicle_global_position_groundtruth(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"differential_pressure",50) == 0) {
		listen_differential_pressure(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"qshell_req",50) == 0) {
		listen_qshell_req(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_correction",50) == 0) {
		listen_sensor_correction(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"landing_target_innovations",50) == 0) {
		listen_landing_target_innovations(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"tecs_status",50) == 0) {
		listen_tecs_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"rate_ctrl_status",50) == 0) {
		listen_rate_ctrl_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"led_control",50) == 0) {
		listen_led_control(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_gps_position",50) == 0) {
		listen_vehicle_gps_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"offboard_control_mode",50) == 0) {
		listen_offboard_control_mode(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_status",50) == 0) {
		listen_vehicle_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"time_offset",50) == 0) {
		listen_time_offset(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"system_power",50) == 0) {
		listen_system_power(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"safety",50) == 0) {
		listen_safety(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"ulog_stream",50) == 0) {
		listen_ulog_stream(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"ulog_stream_ack",50) == 0) {
		listen_ulog_stream_ack(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"gps_inject_data",50) == 0) {
		listen_gps_inject_data(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_preflight",50) == 0) {
		listen_sensor_preflight(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"log_message",50) == 0) {
		listen_log_message(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_outputs",50) == 0) {
		listen_actuator_outputs(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"debug_value",50) == 0) {
		listen_debug_value(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"uavcan_parameter_value",50) == 0) {
		listen_uavcan_parameter_value(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"wind_estimate",50) == 0) {
		listen_wind_estimate(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"power_button_state",50) == 0) {
		listen_power_button_state(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"home_position",50) == 0) {
		listen_home_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"optical_flow",50) == 0) {
		listen_optical_flow(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"ekf2_innovations",50) == 0) {
		listen_ekf2_innovations(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"esc_report",50) == 0) {
		listen_esc_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_attitude_setpoint",50) == 0) {
		listen_vehicle_attitude_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mc_virtual_attitude_setpoint",50) == 0) {
		listen_mc_virtual_attitude_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"fw_virtual_attitude_setpoint",50) == 0) {
		listen_fw_virtual_attitude_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_rates_setpoint",50) == 0) {
		listen_vehicle_rates_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mc_virtual_rates_setpoint",50) == 0) {
		listen_mc_virtual_rates_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"fw_virtual_rates_setpoint",50) == 0) {
		listen_fw_virtual_rates_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"airspeed",50) == 0) {
		listen_airspeed(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"transponder_report",50) == 0) {
		listen_transponder_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_command",50) == 0) {
		listen_vehicle_command(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"cpuload",50) == 0) {
		listen_cpuload(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_attitude",50) == 0) {
		listen_vehicle_attitude(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_attitude_groundtruth",50) == 0) {
		listen_vehicle_attitude_groundtruth(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_vision_attitude",50) == 0) {
		listen_vehicle_vision_attitude(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"debug_vect",50) == 0) {
		listen_debug_vect(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"manual_control_setpoint",50) == 0) {
		listen_manual_control_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"tune_control",50) == 0) {
		listen_tune_control(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_direct",50) == 0) {
		listen_actuator_direct(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"camera_capture",50) == 0) {
		listen_camera_capture(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"geofence_result",50) == 0) {
		listen_geofence_result(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mission",50) == 0) {
		listen_mission(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"battery_status",50) == 0) {
		listen_battery_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_control_mode",50) == 0) {
		listen_vehicle_control_mode(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls",50) == 0) {
		listen_actuator_controls(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_0",50) == 0) {
		listen_actuator_controls_0(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_1",50) == 0) {
		listen_actuator_controls_1(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_2",50) == 0) {
		listen_actuator_controls_2(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_3",50) == 0) {
		listen_actuator_controls_3(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_virtual_fw",50) == 0) {
		listen_actuator_controls_virtual_fw(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_virtual_mc",50) == 0) {
		listen_actuator_controls_virtual_mc(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_status_flags",50) == 0) {
		listen_vehicle_status_flags(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_combined",50) == 0) {
		listen_sensor_combined(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"esc_status",50) == 0) {
		listen_esc_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"test_motor",50) == 0) {
		listen_test_motor(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mission_result",50) == 0) {
		listen_mission_result(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"gps_dump",50) == 0) {
		listen_gps_dump(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mavlink_log",50) == 0) {
		listen_mavlink_log(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"fw_pos_ctrl_status",50) == 0) {
		listen_fw_pos_ctrl_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"subsystem_info",50) == 0) {
		listen_subsystem_info(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mount_orientation",50) == 0) {
		listen_mount_orientation(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_command_ack",50) == 0) {
		listen_vehicle_command_ack(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"input_rc",50) == 0) {
		listen_input_rc(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"landing_target_pose",50) == 0) {
		listen_landing_target_pose(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"debug_key_value",50) == 0) {
		listen_debug_key_value(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"distance_sensor",50) == 0) {
		listen_distance_sensor(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"estimator_status",50) == 0) {
		listen_estimator_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"obstacle_distance",50) == 0) {
		listen_obstacle_distance(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"lqr_controls",50) == 0) {
		listen_lqr_controls(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"telemetry_status",50) == 0) {
		listen_telemetry_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"irlock_report",50) == 0) {
		listen_irlock_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_mag",50) == 0) {
		listen_sensor_mag(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"uavcan_parameter_request",50) == 0) {
		listen_uavcan_parameter_request(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_land_detected",50) == 0) {
		listen_vehicle_land_detected(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_selection",50) == 0) {
		listen_sensor_selection(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_baro",50) == 0) {
		listen_sensor_baro(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"satellite_info",50) == 0) {
		listen_satellite_info(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"task_stack_info",50) == 0) {
		listen_task_stack_info(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_gyro",50) == 0) {
		listen_sensor_gyro(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_local_position",50) == 0) {
		listen_vehicle_local_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_local_position_groundtruth",50) == 0) {
		listen_vehicle_local_position_groundtruth(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_vision_position",50) == 0) {
		listen_vehicle_vision_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_accel",50) == 0) {
		listen_sensor_accel(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"camera_trigger",50) == 0) {
		listen_camera_trigger(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_armed",50) == 0) {
		listen_actuator_armed(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"commander_state",50) == 0) {
		listen_commander_state(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_roi",50) == 0) {
		listen_vehicle_roi(num_msgs, topic_instance);
	} else {
		 printf(" Topic did not match any known topics\n");
	}
	 return 0;
}

void listen_parameter_update(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(parameter_update), topic_instance);
	orb_id_t ID = ORB_ID(parameter_update);
	struct parameter_update_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: parameter_update instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("instance: %u\n",container.instance);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vtol_vehicle_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vtol_vehicle_status), topic_instance);
	orb_id_t ID = ORB_ID(vtol_vehicle_status);
	struct vtol_vehicle_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vtol_vehicle_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("vtol_in_rw_mode: %s\n",container.vtol_in_rw_mode ? "True" : "False");
		printf("vtol_in_trans_mode: %s\n",container.vtol_in_trans_mode ? "True" : "False");
		printf("in_transition_to_fw: %s\n",container.in_transition_to_fw ? "True" : "False");
		printf("vtol_transition_failsafe: %s\n",container.vtol_transition_failsafe ? "True" : "False");
		printf("fw_permanent_stab: %s\n",container.fw_permanent_stab ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_bias(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_bias), topic_instance);
	orb_id_t ID = ORB_ID(sensor_bias);
	struct sensor_bias_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_bias instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("gyro_x: %8.4f\n",(double)container.gyro_x);
		printf("gyro_y: %8.4f\n",(double)container.gyro_y);
		printf("gyro_z: %8.4f\n",(double)container.gyro_z);
		printf("accel_x: %8.4f\n",(double)container.accel_x);
		printf("accel_y: %8.4f\n",(double)container.accel_y);
		printf("accel_z: %8.4f\n",(double)container.accel_z);
		printf("mag_x: %8.4f\n",(double)container.mag_x);
		printf("mag_y: %8.4f\n",(double)container.mag_y);
		printf("mag_z: %8.4f\n",(double)container.mag_z);
		printf("gyro_x_bias: %8.4f\n",(double)container.gyro_x_bias);
		printf("gyro_y_bias: %8.4f\n",(double)container.gyro_y_bias);
		printf("gyro_z_bias: %8.4f\n",(double)container.gyro_z_bias);
		printf("accel_x_bias: %8.4f\n",(double)container.accel_x_bias);
		printf("accel_y_bias: %8.4f\n",(double)container.accel_y_bias);
		printf("accel_z_bias: %8.4f\n",(double)container.accel_z_bias);
		printf("mag_x_bias: %8.4f\n",(double)container.mag_x_bias);
		printf("mag_y_bias: %8.4f\n",(double)container.mag_y_bias);
		printf("mag_z_bias: %8.4f\n",(double)container.mag_z_bias);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_rc_parameter_map(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(rc_parameter_map), topic_instance);
	orb_id_t ID = ORB_ID(rc_parameter_map);
	struct rc_parameter_map_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: rc_parameter_map instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("param_index: ");
		for (int j = 0; j < 3; j++) {
			printf("%d ",container.param_index[j]);
		}
		printf("\n");
		printf("scale: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.scale[j]);
		}
		printf("\n");
		printf("value0: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.value0[j]);
		}
		printf("\n");
		printf("value_min: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.value_min[j]);
		}
		printf("\n");
		printf("value_max: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.value_max[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_ekf2_timestamps(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(ekf2_timestamps), topic_instance);
	orb_id_t ID = ORB_ID(ekf2_timestamps);
	struct ekf2_timestamps_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: ekf2_timestamps instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("gps_timestamp_rel: %d\n",(int)container.gps_timestamp_rel);
		printf("optical_flow_timestamp_rel: %d\n",(int)container.optical_flow_timestamp_rel);
		printf("distance_sensor_timestamp_rel: %d\n",(int)container.distance_sensor_timestamp_rel);
		printf("airspeed_timestamp_rel: %d\n",(int)container.airspeed_timestamp_rel);
		printf("vision_position_timestamp_rel: %d\n",(int)container.vision_position_timestamp_rel);
		printf("vision_attitude_timestamp_rel: %d\n",(int)container.vision_attitude_timestamp_rel);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_collision_report(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(collision_report), topic_instance);
	orb_id_t ID = ORB_ID(collision_report);
	struct collision_report_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: collision_report instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("src: %u\n",(unsigned)container.src);
		printf("id: %u\n",container.id);
		printf("action: %u\n",(unsigned)container.action);
		printf("threat_level: %u\n",(unsigned)container.threat_level);
		printf("time_to_minimum_delta: %8.4f\n",(double)container.time_to_minimum_delta);
		printf("altitude_minimum_delta: %8.4f\n",(double)container.altitude_minimum_delta);
		printf("horizontal_minimum_delta: %8.4f\n",(double)container.horizontal_minimum_delta);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_adc_report(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(adc_report), topic_instance);
	orb_id_t ID = ORB_ID(adc_report);
	struct adc_report_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: adc_report instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("channel_id: ");
		for (int j = 0; j < 12; j++) {
			printf("%d ",container.channel_id[j]);
		}
		printf("\n");
		printf("channel_value: ");
		for (int j = 0; j < 12; j++) {
			printf("%8.4f ",(double)container.channel_value[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_att_pos_mocap(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(att_pos_mocap), topic_instance);
	orb_id_t ID = ORB_ID(att_pos_mocap);
	struct att_pos_mocap_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: att_pos_mocap instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("id: %u\n",container.id);
		printf("timestamp_received: %" PRIu64 "\n",container.timestamp_received);
		printf("q: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q[j]);
		}
		printf("\n");
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_follow_target(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(follow_target), topic_instance);
	orb_id_t ID = ORB_ID(follow_target);
	struct follow_target_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: follow_target instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("alt: %8.4f\n",(double)container.alt);
		printf("vy: %8.4f\n",(double)container.vy);
		printf("vx: %8.4f\n",(double)container.vx);
		printf("vz: %8.4f\n",(double)container.vz);
		printf("est_cap: %u\n",(unsigned)container.est_cap);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_rc_channels(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(rc_channels), topic_instance);
	orb_id_t ID = ORB_ID(rc_channels);
	struct rc_channels_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: rc_channels instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_last_valid: %" PRIu64 "\n",container.timestamp_last_valid);
		printf("channels: ");
		for (int j = 0; j < 18; j++) {
			printf("%8.4f ",(double)container.channels[j]);
		}
		printf("\n");
		printf("channel_count: %u\n",(unsigned)container.channel_count);
		printf("rssi: %u\n",(unsigned)container.rssi);
		printf("signal_lost: %s\n",container.signal_lost ? "True" : "False");
		printf("frame_drop_count: %u\n",container.frame_drop_count);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_multirotor_motor_limits(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(multirotor_motor_limits), topic_instance);
	orb_id_t ID = ORB_ID(multirotor_motor_limits);
	struct multirotor_motor_limits_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: multirotor_motor_limits instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("saturation_status: %u\n",(unsigned)container.saturation_status);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_servorail_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(servorail_status), topic_instance);
	orb_id_t ID = ORB_ID(servorail_status);
	struct servorail_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: servorail_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("voltage_v: %8.4f\n",(double)container.voltage_v);
		printf("rssi_v: %8.4f\n",(double)container.rssi_v);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_global_position(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_global_position), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_global_position);
	struct vehicle_global_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_global_position instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("alt: %8.4f\n",(double)container.alt);
		printf("delta_alt: %8.4f\n",(double)container.delta_alt);
		printf("lat_lon_reset_counter: %u\n",(unsigned)container.lat_lon_reset_counter);
		printf("alt_reset_counter: %u\n",(unsigned)container.alt_reset_counter);
		printf("vel_n: %8.4f\n",(double)container.vel_n);
		printf("vel_e: %8.4f\n",(double)container.vel_e);
		printf("vel_d: %8.4f\n",(double)container.vel_d);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("eph: %8.4f\n",(double)container.eph);
		printf("epv: %8.4f\n",(double)container.epv);
		printf("evh: %8.4f\n",(double)container.evh);
		printf("evv: %8.4f\n",(double)container.evv);
		printf("terrain_alt: %8.4f\n",(double)container.terrain_alt);
		printf("terrain_alt_valid: %s\n",container.terrain_alt_valid ? "True" : "False");
		printf("pressure_alt: %8.4f\n",(double)container.pressure_alt);
		printf("dead_reckoning: %s\n",container.dead_reckoning ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_global_position_groundtruth(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_global_position_groundtruth), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_global_position_groundtruth);
	struct vehicle_global_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_global_position_groundtruth instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("alt: %8.4f\n",(double)container.alt);
		printf("delta_alt: %8.4f\n",(double)container.delta_alt);
		printf("lat_lon_reset_counter: %u\n",(unsigned)container.lat_lon_reset_counter);
		printf("alt_reset_counter: %u\n",(unsigned)container.alt_reset_counter);
		printf("vel_n: %8.4f\n",(double)container.vel_n);
		printf("vel_e: %8.4f\n",(double)container.vel_e);
		printf("vel_d: %8.4f\n",(double)container.vel_d);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("eph: %8.4f\n",(double)container.eph);
		printf("epv: %8.4f\n",(double)container.epv);
		printf("evh: %8.4f\n",(double)container.evh);
		printf("evv: %8.4f\n",(double)container.evv);
		printf("terrain_alt: %8.4f\n",(double)container.terrain_alt);
		printf("terrain_alt_valid: %s\n",container.terrain_alt_valid ? "True" : "False");
		printf("pressure_alt: %8.4f\n",(double)container.pressure_alt);
		printf("dead_reckoning: %s\n",container.dead_reckoning ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_differential_pressure(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(differential_pressure), topic_instance);
	orb_id_t ID = ORB_ID(differential_pressure);
	struct differential_pressure_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: differential_pressure instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("error_count: %" PRIu64 "\n",container.error_count);
		printf("differential_pressure_raw_pa: %8.4f\n",(double)container.differential_pressure_raw_pa);
		printf("differential_pressure_filtered_pa: %8.4f\n",(double)container.differential_pressure_filtered_pa);
		printf("temperature: %8.4f\n",(double)container.temperature);
		printf("device_id: %u\n",container.device_id);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_qshell_req(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(qshell_req), topic_instance);
	orb_id_t ID = ORB_ID(qshell_req);
	struct qshell_req_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: qshell_req instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("string: ");
		for (int j = 0; j < 100; j++) {
			printf("%d ",container.string[j]);
		}
		printf("\n");
		printf("strlen: %" PRIu64 "\n",container.strlen);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_correction(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_correction), topic_instance);
	orb_id_t ID = ORB_ID(sensor_correction);
	struct sensor_correction_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_correction instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("gyro_offset_0: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_offset_0[j]);
		}
		printf("\n");
		printf("gyro_scale_0: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_scale_0[j]);
		}
		printf("\n");
		printf("gyro_offset_1: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_offset_1[j]);
		}
		printf("\n");
		printf("gyro_scale_1: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_scale_1[j]);
		}
		printf("\n");
		printf("gyro_offset_2: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_offset_2[j]);
		}
		printf("\n");
		printf("gyro_scale_2: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_scale_2[j]);
		}
		printf("\n");
		printf("accel_offset_0: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accel_offset_0[j]);
		}
		printf("\n");
		printf("accel_scale_0: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accel_scale_0[j]);
		}
		printf("\n");
		printf("accel_offset_1: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accel_offset_1[j]);
		}
		printf("\n");
		printf("accel_scale_1: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accel_scale_1[j]);
		}
		printf("\n");
		printf("accel_offset_2: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accel_offset_2[j]);
		}
		printf("\n");
		printf("accel_scale_2: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accel_scale_2[j]);
		}
		printf("\n");
		printf("baro_offset_0: %8.4f\n",(double)container.baro_offset_0);
		printf("baro_scale_0: %8.4f\n",(double)container.baro_scale_0);
		printf("baro_offset_1: %8.4f\n",(double)container.baro_offset_1);
		printf("baro_scale_1: %8.4f\n",(double)container.baro_scale_1);
		printf("baro_offset_2: %8.4f\n",(double)container.baro_offset_2);
		printf("baro_scale_2: %8.4f\n",(double)container.baro_scale_2);
		printf("selected_gyro_instance: %u\n",(unsigned)container.selected_gyro_instance);
		printf("selected_accel_instance: %u\n",(unsigned)container.selected_accel_instance);
		printf("selected_baro_instance: %u\n",(unsigned)container.selected_baro_instance);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_landing_target_innovations(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(landing_target_innovations), topic_instance);
	orb_id_t ID = ORB_ID(landing_target_innovations);
	struct landing_target_innovations_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: landing_target_innovations instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("innov_x: %8.4f\n",(double)container.innov_x);
		printf("innov_y: %8.4f\n",(double)container.innov_y);
		printf("innov_cov_x: %8.4f\n",(double)container.innov_cov_x);
		printf("innov_cov_y: %8.4f\n",(double)container.innov_cov_y);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_tecs_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(tecs_status), topic_instance);
	orb_id_t ID = ORB_ID(tecs_status);
	struct tecs_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: tecs_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("altitudeSp: %8.4f\n",(double)container.altitudeSp);
		printf("altitude_filtered: %8.4f\n",(double)container.altitude_filtered);
		printf("flightPathAngleSp: %8.4f\n",(double)container.flightPathAngleSp);
		printf("flightPathAngle: %8.4f\n",(double)container.flightPathAngle);
		printf("airspeedSp: %8.4f\n",(double)container.airspeedSp);
		printf("airspeed_filtered: %8.4f\n",(double)container.airspeed_filtered);
		printf("airspeedDerivativeSp: %8.4f\n",(double)container.airspeedDerivativeSp);
		printf("airspeedDerivative: %8.4f\n",(double)container.airspeedDerivative);
		printf("totalEnergyError: %8.4f\n",(double)container.totalEnergyError);
		printf("energyDistributionError: %8.4f\n",(double)container.energyDistributionError);
		printf("totalEnergyRateError: %8.4f\n",(double)container.totalEnergyRateError);
		printf("energyDistributionRateError: %8.4f\n",(double)container.energyDistributionRateError);
		printf("throttle_integ: %8.4f\n",(double)container.throttle_integ);
		printf("pitch_integ: %8.4f\n",(double)container.pitch_integ);
		printf("mode: %u\n",(unsigned)container.mode);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_rate_ctrl_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(rate_ctrl_status), topic_instance);
	orb_id_t ID = ORB_ID(rate_ctrl_status);
	struct rate_ctrl_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: rate_ctrl_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("rollspeed: %8.4f\n",(double)container.rollspeed);
		printf("pitchspeed: %8.4f\n",(double)container.pitchspeed);
		printf("yawspeed: %8.4f\n",(double)container.yawspeed);
		printf("rollspeed_integ: %8.4f\n",(double)container.rollspeed_integ);
		printf("pitchspeed_integ: %8.4f\n",(double)container.pitchspeed_integ);
		printf("yawspeed_integ: %8.4f\n",(double)container.yawspeed_integ);
		printf("additional_integ1: %8.4f\n",(double)container.additional_integ1);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_led_control(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(led_control), topic_instance);
	orb_id_t ID = ORB_ID(led_control);
	struct led_control_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: led_control instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("led_mask: %u\n",(unsigned)container.led_mask);
		printf("color: %u\n",(unsigned)container.color);
		printf("mode: %u\n",(unsigned)container.mode);
		printf("num_blinks: %u\n",(unsigned)container.num_blinks);
		printf("priority: %u\n",(unsigned)container.priority);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_gps_position(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_gps_position), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_gps_position);
	struct vehicle_gps_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_gps_position instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("lat: %d\n",container.lat);
		printf("lon: %d\n",container.lon);
		printf("alt: %d\n",container.alt);
		printf("alt_ellipsoid: %d\n",container.alt_ellipsoid);
		printf("s_variance_m_s: %8.4f\n",(double)container.s_variance_m_s);
		printf("c_variance_rad: %8.4f\n",(double)container.c_variance_rad);
		printf("fix_type: %u\n",(unsigned)container.fix_type);
		printf("eph: %8.4f\n",(double)container.eph);
		printf("epv: %8.4f\n",(double)container.epv);
		printf("hdop: %8.4f\n",(double)container.hdop);
		printf("vdop: %8.4f\n",(double)container.vdop);
		printf("noise_per_ms: %d\n",container.noise_per_ms);
		printf("jamming_indicator: %d\n",container.jamming_indicator);
		printf("vel_m_s: %8.4f\n",(double)container.vel_m_s);
		printf("vel_n_m_s: %8.4f\n",(double)container.vel_n_m_s);
		printf("vel_e_m_s: %8.4f\n",(double)container.vel_e_m_s);
		printf("vel_d_m_s: %8.4f\n",(double)container.vel_d_m_s);
		printf("cog_rad: %8.4f\n",(double)container.cog_rad);
		printf("vel_ned_valid: %s\n",container.vel_ned_valid ? "True" : "False");
		printf("time_utc_usec: %" PRIu64 "\n",container.time_utc_usec);
		printf("satellites_used: %u\n",(unsigned)container.satellites_used);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_offboard_control_mode(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(offboard_control_mode), topic_instance);
	orb_id_t ID = ORB_ID(offboard_control_mode);
	struct offboard_control_mode_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: offboard_control_mode instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("ignore_thrust: %s\n",container.ignore_thrust ? "True" : "False");
		printf("ignore_attitude: %s\n",container.ignore_attitude ? "True" : "False");
		printf("ignore_bodyrate: %s\n",container.ignore_bodyrate ? "True" : "False");
		printf("ignore_position: %s\n",container.ignore_position ? "True" : "False");
		printf("ignore_velocity: %s\n",container.ignore_velocity ? "True" : "False");
		printf("ignore_acceleration_force: %s\n",container.ignore_acceleration_force ? "True" : "False");
		printf("ignore_alt_hold: %s\n",container.ignore_alt_hold ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_status), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_status);
	struct vehicle_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("nav_state: %u\n",(unsigned)container.nav_state);
		printf("arming_state: %u\n",(unsigned)container.arming_state);
		printf("hil_state: %u\n",(unsigned)container.hil_state);
		printf("failsafe: %s\n",container.failsafe ? "True" : "False");
		printf("system_type: %u\n",(unsigned)container.system_type);
		printf("system_id: %u\n",(unsigned)container.system_id);
		printf("component_id: %u\n",(unsigned)container.component_id);
		printf("is_rotary_wing: %s\n",container.is_rotary_wing ? "True" : "False");
		printf("is_vtol: %s\n",container.is_vtol ? "True" : "False");
		printf("vtol_fw_permanent_stab: %s\n",container.vtol_fw_permanent_stab ? "True" : "False");
		printf("in_transition_mode: %s\n",container.in_transition_mode ? "True" : "False");
		printf("in_transition_to_fw: %s\n",container.in_transition_to_fw ? "True" : "False");
		printf("rc_signal_lost: %s\n",container.rc_signal_lost ? "True" : "False");
		printf("rc_input_mode: %u\n",(unsigned)container.rc_input_mode);
		printf("data_link_lost: %s\n",container.data_link_lost ? "True" : "False");
		printf("data_link_lost_counter: %u\n",(unsigned)container.data_link_lost_counter);
		printf("engine_failure: %s\n",container.engine_failure ? "True" : "False");
		printf("mission_failure: %s\n",container.mission_failure ? "True" : "False");
		printf("onboard_control_sensors_present: %u\n",container.onboard_control_sensors_present);
		printf("onboard_control_sensors_enabled: %u\n",container.onboard_control_sensors_enabled);
		printf("onboard_control_sensors_health: %u\n",container.onboard_control_sensors_health);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_time_offset(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(time_offset), topic_instance);
	orb_id_t ID = ORB_ID(time_offset);
	struct time_offset_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: time_offset instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("offset_ns: %" PRIu64 "\n",container.offset_ns);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_system_power(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(system_power), topic_instance);
	orb_id_t ID = ORB_ID(system_power);
	struct system_power_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: system_power instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("voltage5V_v: %8.4f\n",(double)container.voltage5V_v);
		printf("voltage3V3_v: %8.4f\n",(double)container.voltage3V3_v);
		printf("v3v3_valid: %u\n",(unsigned)container.v3v3_valid);
		printf("usb_connected: %u\n",(unsigned)container.usb_connected);
		printf("brick_valid: %u\n",(unsigned)container.brick_valid);
		printf("usb_valid: %u\n",(unsigned)container.usb_valid);
		printf("servo_valid: %u\n",(unsigned)container.servo_valid);
		printf("periph_5V_OC: %u\n",(unsigned)container.periph_5V_OC);
		printf("hipower_5V_OC: %u\n",(unsigned)container.hipower_5V_OC);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_safety(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(safety), topic_instance);
	orb_id_t ID = ORB_ID(safety);
	struct safety_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: safety instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("safety_switch_available: %s\n",container.safety_switch_available ? "True" : "False");
		printf("safety_off: %s\n",container.safety_off ? "True" : "False");
		printf("override_available: %s\n",container.override_available ? "True" : "False");
		printf("override_enabled: %s\n",container.override_enabled ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_ulog_stream(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(ulog_stream), topic_instance);
	orb_id_t ID = ORB_ID(ulog_stream);
	struct ulog_stream_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: ulog_stream instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("length: %u\n",(unsigned)container.length);
		printf("first_message_offset: %u\n",(unsigned)container.first_message_offset);
		printf("sequence: %u\n",(unsigned)container.sequence);
		printf("flags: %u\n",(unsigned)container.flags);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_ulog_stream_ack(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(ulog_stream_ack), topic_instance);
	orb_id_t ID = ORB_ID(ulog_stream_ack);
	struct ulog_stream_ack_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: ulog_stream_ack instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("sequence: %u\n",(unsigned)container.sequence);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_gps_inject_data(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(gps_inject_data), topic_instance);
	orb_id_t ID = ORB_ID(gps_inject_data);
	struct gps_inject_data_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: gps_inject_data instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("len: %u\n",(unsigned)container.len);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_preflight(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_preflight), topic_instance);
	orb_id_t ID = ORB_ID(sensor_preflight);
	struct sensor_preflight_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_preflight instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("accel_inconsistency_m_s_s: %8.4f\n",(double)container.accel_inconsistency_m_s_s);
		printf("gyro_inconsistency_rad_s: %8.4f\n",(double)container.gyro_inconsistency_rad_s);
		printf("mag_inconsistency_ga: %8.4f\n",(double)container.mag_inconsistency_ga);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_log_message(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(log_message), topic_instance);
	orb_id_t ID = ORB_ID(log_message);
	struct log_message_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: log_message instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("severity: %u\n",(unsigned)container.severity);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_outputs(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_outputs), topic_instance);
	orb_id_t ID = ORB_ID(actuator_outputs);
	struct actuator_outputs_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_outputs instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("noutputs: %u\n",container.noutputs);
		printf("output: ");
		for (int j = 0; j < 16; j++) {
			printf("%8.4f ",(double)container.output[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_debug_value(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(debug_value), topic_instance);
	orb_id_t ID = ORB_ID(debug_value);
	struct debug_value_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: debug_value instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_ms: %u\n",container.timestamp_ms);
		printf("ind: %d\n",(int)container.ind);
		printf("value: %8.4f\n",(double)container.value);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_uavcan_parameter_value(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(uavcan_parameter_value), topic_instance);
	orb_id_t ID = ORB_ID(uavcan_parameter_value);
	struct uavcan_parameter_value_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: uavcan_parameter_value instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("node_id: %u\n",(unsigned)container.node_id);
		printf("param_index: %d\n",(int)container.param_index);
		printf("param_count: %u\n",(unsigned)container.param_count);
		printf("param_type: %u\n",(unsigned)container.param_type);
		printf("int_value: %" PRId64 "\n",container.int_value);
		printf("real_value: %8.4f\n",(double)container.real_value);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_wind_estimate(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(wind_estimate), topic_instance);
	orb_id_t ID = ORB_ID(wind_estimate);
	struct wind_estimate_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: wind_estimate instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("windspeed_north: %8.4f\n",(double)container.windspeed_north);
		printf("windspeed_east: %8.4f\n",(double)container.windspeed_east);
		printf("variance_north: %8.4f\n",(double)container.variance_north);
		printf("variance_east: %8.4f\n",(double)container.variance_east);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_power_button_state(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(power_button_state), topic_instance);
	orb_id_t ID = ORB_ID(power_button_state);
	struct power_button_state_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: power_button_state instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("event: %u\n",(unsigned)container.event);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_home_position(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(home_position), topic_instance);
	orb_id_t ID = ORB_ID(home_position);
	struct home_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: home_position instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("alt: %8.4f\n",(double)container.alt);
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("valid_alt: %s\n",container.valid_alt ? "True" : "False");
		printf("valid_hpos: %s\n",container.valid_hpos ? "True" : "False");
		printf("manual_home: %s\n",container.manual_home ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_optical_flow(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(optical_flow), topic_instance);
	orb_id_t ID = ORB_ID(optical_flow);
	struct optical_flow_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: optical_flow instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("sensor_id: %u\n",(unsigned)container.sensor_id);
		printf("pixel_flow_x_integral: %8.4f\n",(double)container.pixel_flow_x_integral);
		printf("pixel_flow_y_integral: %8.4f\n",(double)container.pixel_flow_y_integral);
		printf("gyro_x_rate_integral: %8.4f\n",(double)container.gyro_x_rate_integral);
		printf("gyro_y_rate_integral: %8.4f\n",(double)container.gyro_y_rate_integral);
		printf("gyro_z_rate_integral: %8.4f\n",(double)container.gyro_z_rate_integral);
		printf("ground_distance_m: %8.4f\n",(double)container.ground_distance_m);
		printf("integration_timespan: %u\n",container.integration_timespan);
		printf("time_since_last_sonar_update: %u\n",container.time_since_last_sonar_update);
		printf("frame_count_since_last_readout: %u\n",(unsigned)container.frame_count_since_last_readout);
		printf("gyro_temperature: %d\n",(int)container.gyro_temperature);
		printf("quality: %u\n",(unsigned)container.quality);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_ekf2_innovations(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(ekf2_innovations), topic_instance);
	orb_id_t ID = ORB_ID(ekf2_innovations);
	struct ekf2_innovations_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: ekf2_innovations instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("vel_pos_innov: ");
		for (int j = 0; j < 6; j++) {
			printf("%8.4f ",(double)container.vel_pos_innov[j]);
		}
		printf("\n");
		printf("mag_innov: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.mag_innov[j]);
		}
		printf("\n");
		printf("heading_innov: %8.4f\n",(double)container.heading_innov);
		printf("airspeed_innov: %8.4f\n",(double)container.airspeed_innov);
		printf("beta_innov: %8.4f\n",(double)container.beta_innov);
		printf("flow_innov: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.flow_innov[j]);
		}
		printf("\n");
		printf("hagl_innov: %8.4f\n",(double)container.hagl_innov);
		printf("vel_pos_innov_var: ");
		for (int j = 0; j < 6; j++) {
			printf("%8.4f ",(double)container.vel_pos_innov_var[j]);
		}
		printf("\n");
		printf("mag_innov_var: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.mag_innov_var[j]);
		}
		printf("\n");
		printf("heading_innov_var: %8.4f\n",(double)container.heading_innov_var);
		printf("airspeed_innov_var: %8.4f\n",(double)container.airspeed_innov_var);
		printf("beta_innov_var: %8.4f\n",(double)container.beta_innov_var);
		printf("flow_innov_var: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.flow_innov_var[j]);
		}
		printf("\n");
		printf("hagl_innov_var: %8.4f\n",(double)container.hagl_innov_var);
		printf("output_tracking_error: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.output_tracking_error[j]);
		}
		printf("\n");
		printf("drag_innov: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.drag_innov[j]);
		}
		printf("\n");
		printf("drag_innov_var: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.drag_innov_var[j]);
		}
		printf("\n");
		printf("aux_vel_innov: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.aux_vel_innov[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_esc_report(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(esc_report), topic_instance);
	orb_id_t ID = ORB_ID(esc_report);
	struct esc_report_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: esc_report instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("esc_vendor: %u\n",(unsigned)container.esc_vendor);
		printf("esc_errorcount: %u\n",container.esc_errorcount);
		printf("esc_rpm: %d\n",container.esc_rpm);
		printf("esc_voltage: %8.4f\n",(double)container.esc_voltage);
		printf("esc_current: %8.4f\n",(double)container.esc_current);
		printf("esc_temperature: %8.4f\n",(double)container.esc_temperature);
		printf("esc_setpoint: %8.4f\n",(double)container.esc_setpoint);
		printf("esc_setpoint_raw: %u\n",(unsigned)container.esc_setpoint_raw);
		printf("esc_address: %u\n",(unsigned)container.esc_address);
		printf("esc_version: %u\n",(unsigned)container.esc_version);
		printf("esc_state: %u\n",(unsigned)container.esc_state);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_attitude_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_attitude_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_attitude_setpoint);
	struct vehicle_attitude_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_attitude_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll_body: %8.4f\n",(double)container.roll_body);
		printf("pitch_body: %8.4f\n",(double)container.pitch_body);
		printf("yaw_body: %8.4f\n",(double)container.yaw_body);
		printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
		printf("q_d: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q_d[j]);
		}
		printf("\n");
		printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
		printf("thrust: %8.4f\n",(double)container.thrust);
		printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
		printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
		printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
		printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
		printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
		printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
		printf("landing_gear: %8.4f\n",(double)container.landing_gear);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mc_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(mc_virtual_attitude_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(mc_virtual_attitude_setpoint);
	struct vehicle_attitude_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: mc_virtual_attitude_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll_body: %8.4f\n",(double)container.roll_body);
		printf("pitch_body: %8.4f\n",(double)container.pitch_body);
		printf("yaw_body: %8.4f\n",(double)container.yaw_body);
		printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
		printf("q_d: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q_d[j]);
		}
		printf("\n");
		printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
		printf("thrust: %8.4f\n",(double)container.thrust);
		printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
		printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
		printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
		printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
		printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
		printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
		printf("landing_gear: %8.4f\n",(double)container.landing_gear);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_fw_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(fw_virtual_attitude_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(fw_virtual_attitude_setpoint);
	struct vehicle_attitude_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: fw_virtual_attitude_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll_body: %8.4f\n",(double)container.roll_body);
		printf("pitch_body: %8.4f\n",(double)container.pitch_body);
		printf("yaw_body: %8.4f\n",(double)container.yaw_body);
		printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
		printf("q_d: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q_d[j]);
		}
		printf("\n");
		printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
		printf("thrust: %8.4f\n",(double)container.thrust);
		printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
		printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
		printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
		printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
		printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
		printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
		printf("landing_gear: %8.4f\n",(double)container.landing_gear);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_rates_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_rates_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_rates_setpoint);
	struct vehicle_rates_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_rates_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll: %8.4f\n",(double)container.roll);
		printf("pitch: %8.4f\n",(double)container.pitch);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("thrust: %8.4f\n",(double)container.thrust);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mc_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(mc_virtual_rates_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(mc_virtual_rates_setpoint);
	struct vehicle_rates_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: mc_virtual_rates_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll: %8.4f\n",(double)container.roll);
		printf("pitch: %8.4f\n",(double)container.pitch);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("thrust: %8.4f\n",(double)container.thrust);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_fw_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(fw_virtual_rates_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(fw_virtual_rates_setpoint);
	struct vehicle_rates_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: fw_virtual_rates_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll: %8.4f\n",(double)container.roll);
		printf("pitch: %8.4f\n",(double)container.pitch);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("thrust: %8.4f\n",(double)container.thrust);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_airspeed(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(airspeed), topic_instance);
	orb_id_t ID = ORB_ID(airspeed);
	struct airspeed_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: airspeed instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("indicated_airspeed_m_s: %8.4f\n",(double)container.indicated_airspeed_m_s);
		printf("true_airspeed_m_s: %8.4f\n",(double)container.true_airspeed_m_s);
		printf("true_airspeed_unfiltered_m_s: %8.4f\n",(double)container.true_airspeed_unfiltered_m_s);
		printf("air_temperature_celsius: %8.4f\n",(double)container.air_temperature_celsius);
		printf("confidence: %8.4f\n",(double)container.confidence);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_transponder_report(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(transponder_report), topic_instance);
	orb_id_t ID = ORB_ID(transponder_report);
	struct transponder_report_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: transponder_report instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("ICAO_address: %u\n",container.ICAO_address);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("altitude_type: %u\n",(unsigned)container.altitude_type);
		printf("altitude: %8.4f\n",(double)container.altitude);
		printf("heading: %8.4f\n",(double)container.heading);
		printf("hor_velocity: %8.4f\n",(double)container.hor_velocity);
		printf("ver_velocity: %8.4f\n",(double)container.ver_velocity);
		printf("emitter_type: %u\n",(unsigned)container.emitter_type);
		printf("tslc: %u\n",(unsigned)container.tslc);
		printf("flags: %u\n",(unsigned)container.flags);
		printf("squawk: %u\n",(unsigned)container.squawk);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_command(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_command), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_command);
	struct vehicle_command_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_command instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("param1: %8.4f\n",(double)container.param1);
		printf("param2: %8.4f\n",(double)container.param2);
		printf("param3: %8.4f\n",(double)container.param3);
		printf("param4: %8.4f\n",(double)container.param4);
		printf("param5: %8.4f\n",(double)container.param5);
		printf("param6: %8.4f\n",(double)container.param6);
		printf("param7: %8.4f\n",(double)container.param7);
		printf("command: %u\n",(unsigned)container.command);
		printf("target_system: %u\n",(unsigned)container.target_system);
		printf("target_component: %u\n",(unsigned)container.target_component);
		printf("source_system: %u\n",(unsigned)container.source_system);
		printf("source_component: %u\n",(unsigned)container.source_component);
		printf("confirmation: %u\n",(unsigned)container.confirmation);
		printf("from_external: %s\n",container.from_external ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_cpuload(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(cpuload), topic_instance);
	orb_id_t ID = ORB_ID(cpuload);
	struct cpuload_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: cpuload instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("load: %8.4f\n",(double)container.load);
		printf("ram_usage: %8.4f\n",(double)container.ram_usage);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_attitude(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_attitude), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_attitude);
	struct vehicle_attitude_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_attitude instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("rollspeed: %8.4f\n",(double)container.rollspeed);
		printf("pitchspeed: %8.4f\n",(double)container.pitchspeed);
		printf("yawspeed: %8.4f\n",(double)container.yawspeed);
		printf("q: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q[j]);
		}
		printf("\n");
		printf("delta_q_reset: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.delta_q_reset[j]);
		}
		printf("\n");
		printf("quat_reset_counter: %u\n",(unsigned)container.quat_reset_counter);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_attitude_groundtruth(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_attitude_groundtruth), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_attitude_groundtruth);
	struct vehicle_attitude_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_attitude_groundtruth instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("rollspeed: %8.4f\n",(double)container.rollspeed);
		printf("pitchspeed: %8.4f\n",(double)container.pitchspeed);
		printf("yawspeed: %8.4f\n",(double)container.yawspeed);
		printf("q: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q[j]);
		}
		printf("\n");
		printf("delta_q_reset: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.delta_q_reset[j]);
		}
		printf("\n");
		printf("quat_reset_counter: %u\n",(unsigned)container.quat_reset_counter);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_vision_attitude(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_vision_attitude), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_vision_attitude);
	struct vehicle_attitude_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_vision_attitude instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("rollspeed: %8.4f\n",(double)container.rollspeed);
		printf("pitchspeed: %8.4f\n",(double)container.pitchspeed);
		printf("yawspeed: %8.4f\n",(double)container.yawspeed);
		printf("q: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q[j]);
		}
		printf("\n");
		printf("delta_q_reset: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.delta_q_reset[j]);
		}
		printf("\n");
		printf("quat_reset_counter: %u\n",(unsigned)container.quat_reset_counter);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_debug_vect(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(debug_vect), topic_instance);
	orb_id_t ID = ORB_ID(debug_vect);
	struct debug_vect_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: debug_vect instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_us: %" PRIu64 "\n",container.timestamp_us);
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_manual_control_setpoint(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(manual_control_setpoint), topic_instance);
	orb_id_t ID = ORB_ID(manual_control_setpoint);
	struct manual_control_setpoint_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: manual_control_setpoint instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("r: %8.4f\n",(double)container.r);
		printf("flaps: %8.4f\n",(double)container.flaps);
		printf("aux1: %8.4f\n",(double)container.aux1);
		printf("aux2: %8.4f\n",(double)container.aux2);
		printf("aux3: %8.4f\n",(double)container.aux3);
		printf("aux4: %8.4f\n",(double)container.aux4);
		printf("aux5: %8.4f\n",(double)container.aux5);
		printf("mode_switch: %u\n",(unsigned)container.mode_switch);
		printf("return_switch: %u\n",(unsigned)container.return_switch);
		printf("rattitude_switch: %u\n",(unsigned)container.rattitude_switch);
		printf("posctl_switch: %u\n",(unsigned)container.posctl_switch);
		printf("loiter_switch: %u\n",(unsigned)container.loiter_switch);
		printf("acro_switch: %u\n",(unsigned)container.acro_switch);
		printf("offboard_switch: %u\n",(unsigned)container.offboard_switch);
		printf("kill_switch: %u\n",(unsigned)container.kill_switch);
		printf("arm_switch: %u\n",(unsigned)container.arm_switch);
		printf("transition_switch: %u\n",(unsigned)container.transition_switch);
		printf("gear_switch: %u\n",(unsigned)container.gear_switch);
		printf("mode_slot: %d\n",(int)container.mode_slot);
		printf("data_source: %u\n",(unsigned)container.data_source);
		printf("stab_switch: %u\n",(unsigned)container.stab_switch);
		printf("man_switch: %u\n",(unsigned)container.man_switch);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_tune_control(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(tune_control), topic_instance);
	orb_id_t ID = ORB_ID(tune_control);
	struct tune_control_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: tune_control instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("tune_id: %u\n",(unsigned)container.tune_id);
		printf("tune_override: %u\n",(unsigned)container.tune_override);
		printf("frequency: %u\n",(unsigned)container.frequency);
		printf("duration: %u\n",container.duration);
		printf("silence: %u\n",container.silence);
		printf("strength: %u\n",(unsigned)container.strength);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_direct(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_direct), topic_instance);
	orb_id_t ID = ORB_ID(actuator_direct);
	struct actuator_direct_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_direct instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("nvalues: %u\n",container.nvalues);
		printf("values: ");
		for (int j = 0; j < 16; j++) {
			printf("%8.4f ",(double)container.values[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_camera_capture(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(camera_capture), topic_instance);
	orb_id_t ID = ORB_ID(camera_capture);
	struct camera_capture_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: camera_capture instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_utc: %" PRIu64 "\n",container.timestamp_utc);
		printf("seq: %u\n",container.seq);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("alt: %8.4f\n",(double)container.alt);
		printf("ground_distance: %8.4f\n",(double)container.ground_distance);
		printf("q: ");
		for (int j = 0; j < 4; j++) {
			printf("%8.4f ",(double)container.q[j]);
		}
		printf("\n");
		printf("result: %d\n",(int)container.result);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_geofence_result(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(geofence_result), topic_instance);
	orb_id_t ID = ORB_ID(geofence_result);
	struct geofence_result_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: geofence_result instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("geofence_violated: %s\n",container.geofence_violated ? "True" : "False");
		printf("geofence_action: %u\n",(unsigned)container.geofence_action);
		printf("home_required: %s\n",container.home_required ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mission(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(mission), topic_instance);
	orb_id_t ID = ORB_ID(mission);
	struct mission_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: mission instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("dataman_id: %u\n",(unsigned)container.dataman_id);
		printf("count: %u\n",(unsigned)container.count);
		printf("current_seq: %d\n",container.current_seq);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_battery_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(battery_status), topic_instance);
	orb_id_t ID = ORB_ID(battery_status);
	struct battery_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: battery_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("voltage_v: %8.4f\n",(double)container.voltage_v);
		printf("voltage_filtered_v: %8.4f\n",(double)container.voltage_filtered_v);
		printf("current_a: %8.4f\n",(double)container.current_a);
		printf("current_filtered_a: %8.4f\n",(double)container.current_filtered_a);
		printf("discharged_mah: %8.4f\n",(double)container.discharged_mah);
		printf("remaining: %8.4f\n",(double)container.remaining);
		printf("scale: %8.4f\n",(double)container.scale);
		printf("cell_count: %d\n",container.cell_count);
		printf("connected: %s\n",container.connected ? "True" : "False");
		printf("system_source: %s\n",container.system_source ? "True" : "False");
		printf("priority: %u\n",(unsigned)container.priority);
		printf("is_powering_off: %s\n",container.is_powering_off ? "True" : "False");
		printf("warning: %u\n",(unsigned)container.warning);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_control_mode(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_control_mode), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_control_mode);
	struct vehicle_control_mode_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_control_mode instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("flag_armed: %s\n",container.flag_armed ? "True" : "False");
		printf("flag_external_manual_override_ok: %s\n",container.flag_external_manual_override_ok ? "True" : "False");
		printf("flag_system_hil_enabled: %s\n",container.flag_system_hil_enabled ? "True" : "False");
		printf("flag_control_manual_enabled: %s\n",container.flag_control_manual_enabled ? "True" : "False");
		printf("flag_control_auto_enabled: %s\n",container.flag_control_auto_enabled ? "True" : "False");
		printf("flag_control_offboard_enabled: %s\n",container.flag_control_offboard_enabled ? "True" : "False");
		printf("flag_control_rates_enabled: %s\n",container.flag_control_rates_enabled ? "True" : "False");
		printf("flag_control_attitude_enabled: %s\n",container.flag_control_attitude_enabled ? "True" : "False");
		printf("flag_control_rattitude_enabled: %s\n",container.flag_control_rattitude_enabled ? "True" : "False");
		printf("flag_control_force_enabled: %s\n",container.flag_control_force_enabled ? "True" : "False");
		printf("flag_control_acceleration_enabled: %s\n",container.flag_control_acceleration_enabled ? "True" : "False");
		printf("flag_control_velocity_enabled: %s\n",container.flag_control_velocity_enabled ? "True" : "False");
		printf("flag_control_position_enabled: %s\n",container.flag_control_position_enabled ? "True" : "False");
		printf("flag_control_altitude_enabled: %s\n",container.flag_control_altitude_enabled ? "True" : "False");
		printf("flag_control_climb_rate_enabled: %s\n",container.flag_control_climb_rate_enabled ? "True" : "False");
		printf("flag_control_termination_enabled: %s\n",container.flag_control_termination_enabled ? "True" : "False");
		printf("flag_control_fixed_hdg_enabled: %s\n",container.flag_control_fixed_hdg_enabled ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_0(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_0), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls_0);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls_0 instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_1(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_1), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls_1);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls_1 instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_2(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_2), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls_2);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls_2 instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_3(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_3), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls_3);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls_3 instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_virtual_fw(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_virtual_fw), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls_virtual_fw);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls_virtual_fw instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_virtual_mc(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_virtual_mc), topic_instance);
	orb_id_t ID = ORB_ID(actuator_controls_virtual_mc);
	struct actuator_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_controls_virtual_mc instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
		printf("control: ");
		for (int j = 0; j < 8; j++) {
			printf("%8.4f ",(double)container.control[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_status_flags(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_status_flags), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_status_flags);
	struct vehicle_status_flags_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_status_flags instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("condition_calibration_enabled: %s\n",container.condition_calibration_enabled ? "True" : "False");
		printf("condition_system_sensors_initialized: %s\n",container.condition_system_sensors_initialized ? "True" : "False");
		printf("condition_system_prearm_error_reported: %s\n",container.condition_system_prearm_error_reported ? "True" : "False");
		printf("condition_system_hotplug_timeout: %s\n",container.condition_system_hotplug_timeout ? "True" : "False");
		printf("condition_system_returned_to_home: %s\n",container.condition_system_returned_to_home ? "True" : "False");
		printf("condition_auto_mission_available: %s\n",container.condition_auto_mission_available ? "True" : "False");
		printf("condition_global_position_valid: %s\n",container.condition_global_position_valid ? "True" : "False");
		printf("condition_global_velocity_valid: %s\n",container.condition_global_velocity_valid ? "True" : "False");
		printf("condition_home_position_valid: %s\n",container.condition_home_position_valid ? "True" : "False");
		printf("condition_local_position_valid: %s\n",container.condition_local_position_valid ? "True" : "False");
		printf("condition_local_velocity_valid: %s\n",container.condition_local_velocity_valid ? "True" : "False");
		printf("condition_local_altitude_valid: %s\n",container.condition_local_altitude_valid ? "True" : "False");
		printf("condition_power_input_valid: %s\n",container.condition_power_input_valid ? "True" : "False");
		printf("circuit_breaker_engaged_power_check: %s\n",container.circuit_breaker_engaged_power_check ? "True" : "False");
		printf("circuit_breaker_engaged_airspd_check: %s\n",container.circuit_breaker_engaged_airspd_check ? "True" : "False");
		printf("circuit_breaker_engaged_enginefailure_check: %s\n",container.circuit_breaker_engaged_enginefailure_check ? "True" : "False");
		printf("circuit_breaker_engaged_gpsfailure_check: %s\n",container.circuit_breaker_engaged_gpsfailure_check ? "True" : "False");
		printf("circuit_breaker_flight_termination_disabled: %s\n",container.circuit_breaker_flight_termination_disabled ? "True" : "False");
		printf("circuit_breaker_engaged_usb_check: %s\n",container.circuit_breaker_engaged_usb_check ? "True" : "False");
		printf("circuit_breaker_engaged_posfailure_check: %s\n",container.circuit_breaker_engaged_posfailure_check ? "True" : "False");
		printf("offboard_control_signal_found_once: %s\n",container.offboard_control_signal_found_once ? "True" : "False");
		printf("offboard_control_signal_lost: %s\n",container.offboard_control_signal_lost ? "True" : "False");
		printf("offboard_control_set_by_command: %s\n",container.offboard_control_set_by_command ? "True" : "False");
		printf("offboard_control_loss_timeout: %s\n",container.offboard_control_loss_timeout ? "True" : "False");
		printf("rc_signal_found_once: %s\n",container.rc_signal_found_once ? "True" : "False");
		printf("rc_input_blocked: %s\n",container.rc_input_blocked ? "True" : "False");
		printf("vtol_transition_failure: %s\n",container.vtol_transition_failure ? "True" : "False");
		printf("usb_connected: %s\n",container.usb_connected ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_combined(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_combined), topic_instance);
	orb_id_t ID = ORB_ID(sensor_combined);
	struct sensor_combined_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_combined instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("gyro_rad: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.gyro_rad[j]);
		}
		printf("\n");
		printf("gyro_integral_dt: %u\n",container.gyro_integral_dt);
		printf("accelerometer_m_s2: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.accelerometer_m_s2[j]);
		}
		printf("\n");
		printf("accelerometer_integral_dt: %u\n",container.accelerometer_integral_dt);
		printf("magnetometer_ga: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.magnetometer_ga[j]);
		}
		printf("\n");
		printf("baro_alt_meter: %8.4f\n",(double)container.baro_alt_meter);
		printf("baro_temp_celcius: %8.4f\n",(double)container.baro_temp_celcius);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_esc_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(esc_status), topic_instance);
	orb_id_t ID = ORB_ID(esc_status);
	struct esc_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: esc_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("counter: %u\n",(unsigned)container.counter);
		printf("esc_count: %u\n",(unsigned)container.esc_count);
		printf("esc_connectiontype: %u\n",(unsigned)container.esc_connectiontype);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_test_motor(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(test_motor), topic_instance);
	orb_id_t ID = ORB_ID(test_motor);
	struct test_motor_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: test_motor instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("motor_number: %u\n",container.motor_number);
		printf("value: %8.4f\n",(double)container.value);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mission_result(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(mission_result), topic_instance);
	orb_id_t ID = ORB_ID(mission_result);
	struct mission_result_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: mission_result instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("instance_count: %u\n",container.instance_count);
		printf("seq_reached: %d\n",container.seq_reached);
		printf("seq_current: %u\n",(unsigned)container.seq_current);
		printf("seq_total: %u\n",(unsigned)container.seq_total);
		printf("valid: %s\n",container.valid ? "True" : "False");
		printf("warning: %s\n",container.warning ? "True" : "False");
		printf("finished: %s\n",container.finished ? "True" : "False");
		printf("failure: %s\n",container.failure ? "True" : "False");
		printf("stay_in_failsafe: %s\n",container.stay_in_failsafe ? "True" : "False");
		printf("flight_termination: %s\n",container.flight_termination ? "True" : "False");
		printf("item_do_jump_changed: %s\n",container.item_do_jump_changed ? "True" : "False");
		printf("item_changed_index: %u\n",(unsigned)container.item_changed_index);
		printf("item_do_jump_remaining: %u\n",(unsigned)container.item_do_jump_remaining);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_gps_dump(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(gps_dump), topic_instance);
	orb_id_t ID = ORB_ID(gps_dump);
	struct gps_dump_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: gps_dump instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mavlink_log(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(mavlink_log), topic_instance);
	orb_id_t ID = ORB_ID(mavlink_log);
	struct mavlink_log_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: mavlink_log instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("severity: %u\n",(unsigned)container.severity);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_fw_pos_ctrl_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(fw_pos_ctrl_status), topic_instance);
	orb_id_t ID = ORB_ID(fw_pos_ctrl_status);
	struct fw_pos_ctrl_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: fw_pos_ctrl_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("nav_roll: %8.4f\n",(double)container.nav_roll);
		printf("nav_pitch: %8.4f\n",(double)container.nav_pitch);
		printf("nav_bearing: %8.4f\n",(double)container.nav_bearing);
		printf("target_bearing: %8.4f\n",(double)container.target_bearing);
		printf("wp_dist: %8.4f\n",(double)container.wp_dist);
		printf("xtrack_error: %8.4f\n",(double)container.xtrack_error);
		printf("turn_distance: %8.4f\n",(double)container.turn_distance);
		printf("landing_horizontal_slope_displacement: %8.4f\n",(double)container.landing_horizontal_slope_displacement);
		printf("landing_slope_angle_rad: %8.4f\n",(double)container.landing_slope_angle_rad);
		printf("landing_flare_length: %8.4f\n",(double)container.landing_flare_length);
		printf("abort_landing: %s\n",container.abort_landing ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_subsystem_info(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(subsystem_info), topic_instance);
	orb_id_t ID = ORB_ID(subsystem_info);
	struct subsystem_info_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: subsystem_info instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("present: %s\n",container.present ? "True" : "False");
		printf("enabled: %s\n",container.enabled ? "True" : "False");
		printf("ok: %s\n",container.ok ? "True" : "False");
		printf("subsystem_type: %" PRIu64 "\n",container.subsystem_type);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mount_orientation(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(mount_orientation), topic_instance);
	orb_id_t ID = ORB_ID(mount_orientation);
	struct mount_orientation_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: mount_orientation instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("attitude_euler_angle: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.attitude_euler_angle[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_command_ack(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_command_ack), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_command_ack);
	struct vehicle_command_ack_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_command_ack instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("command: %u\n",(unsigned)container.command);
		printf("result: %u\n",(unsigned)container.result);
		printf("from_external: %s\n",container.from_external ? "True" : "False");
		printf("result_param1: %u\n",(unsigned)container.result_param1);
		printf("result_param2: %d\n",container.result_param2);
		printf("target_system: %u\n",(unsigned)container.target_system);
		printf("target_component: %u\n",(unsigned)container.target_component);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_input_rc(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(input_rc), topic_instance);
	orb_id_t ID = ORB_ID(input_rc);
	struct input_rc_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: input_rc instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_last_signal: %" PRIu64 "\n",container.timestamp_last_signal);
		printf("channel_count: %u\n",container.channel_count);
		printf("rssi: %d\n",container.rssi);
		printf("rc_failsafe: %s\n",container.rc_failsafe ? "True" : "False");
		printf("rc_lost: %s\n",container.rc_lost ? "True" : "False");
		printf("rc_lost_frame_count: %u\n",(unsigned)container.rc_lost_frame_count);
		printf("rc_total_frame_count: %u\n",(unsigned)container.rc_total_frame_count);
		printf("rc_ppm_frame_length: %u\n",(unsigned)container.rc_ppm_frame_length);
		printf("input_source: %u\n",(unsigned)container.input_source);
		printf("values: ");
		for (int j = 0; j < 18; j++) {
			printf("%u ",container.values[j]);
		}
		printf("\n");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_landing_target_pose(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(landing_target_pose), topic_instance);
	orb_id_t ID = ORB_ID(landing_target_pose);
	struct landing_target_pose_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: landing_target_pose instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("is_static: %s\n",container.is_static ? "True" : "False");
		printf("rel_pos_valid: %s\n",container.rel_pos_valid ? "True" : "False");
		printf("rel_vel_valid: %s\n",container.rel_vel_valid ? "True" : "False");
		printf("x_rel: %8.4f\n",(double)container.x_rel);
		printf("y_rel: %8.4f\n",(double)container.y_rel);
		printf("z_rel: %8.4f\n",(double)container.z_rel);
		printf("vx_rel: %8.4f\n",(double)container.vx_rel);
		printf("vy_rel: %8.4f\n",(double)container.vy_rel);
		printf("cov_x_rel: %8.4f\n",(double)container.cov_x_rel);
		printf("cov_y_rel: %8.4f\n",(double)container.cov_y_rel);
		printf("cov_vx_rel: %8.4f\n",(double)container.cov_vx_rel);
		printf("cov_vy_rel: %8.4f\n",(double)container.cov_vy_rel);
		printf("abs_pos_valid: %s\n",container.abs_pos_valid ? "True" : "False");
		printf("x_abs: %8.4f\n",(double)container.x_abs);
		printf("y_abs: %8.4f\n",(double)container.y_abs);
		printf("z_abs: %8.4f\n",(double)container.z_abs);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_debug_key_value(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(debug_key_value), topic_instance);
	orb_id_t ID = ORB_ID(debug_key_value);
	struct debug_key_value_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: debug_key_value instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_ms: %u\n",container.timestamp_ms);
		printf("value: %8.4f\n",(double)container.value);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_distance_sensor(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(distance_sensor), topic_instance);
	orb_id_t ID = ORB_ID(distance_sensor);
	struct distance_sensor_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: distance_sensor instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("min_distance: %8.4f\n",(double)container.min_distance);
		printf("max_distance: %8.4f\n",(double)container.max_distance);
		printf("current_distance: %8.4f\n",(double)container.current_distance);
		printf("covariance: %8.4f\n",(double)container.covariance);
		printf("type: %u\n",(unsigned)container.type);
		printf("id: %u\n",(unsigned)container.id);
		printf("orientation: %u\n",(unsigned)container.orientation);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_estimator_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(estimator_status), topic_instance);
	orb_id_t ID = ORB_ID(estimator_status);
	struct estimator_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: estimator_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("states: ");
		for (int j = 0; j < 24; j++) {
			printf("%8.4f ",(double)container.states[j]);
		}
		printf("\n");
		printf("n_states: %8.4f\n",(double)container.n_states);
		printf("vibe: ");
		for (int j = 0; j < 3; j++) {
			printf("%8.4f ",(double)container.vibe[j]);
		}
		printf("\n");
		printf("nan_flags: %u\n",(unsigned)container.nan_flags);
		printf("health_flags: %u\n",(unsigned)container.health_flags);
		printf("timeout_flags: %u\n",(unsigned)container.timeout_flags);
		printf("covariances: ");
		for (int j = 0; j < 24; j++) {
			printf("%8.4f ",(double)container.covariances[j]);
		}
		printf("\n");
		printf("gps_check_fail_flags: %u\n",(unsigned)container.gps_check_fail_flags);
		printf("control_mode_flags: %u\n",container.control_mode_flags);
		printf("filter_fault_flags: %u\n",(unsigned)container.filter_fault_flags);
		printf("pos_horiz_accuracy: %8.4f\n",(double)container.pos_horiz_accuracy);
		printf("pos_vert_accuracy: %8.4f\n",(double)container.pos_vert_accuracy);
		printf("innovation_check_flags: %u\n",(unsigned)container.innovation_check_flags);
		printf("mag_test_ratio: %8.4f\n",(double)container.mag_test_ratio);
		printf("vel_test_ratio: %8.4f\n",(double)container.vel_test_ratio);
		printf("pos_test_ratio: %8.4f\n",(double)container.pos_test_ratio);
		printf("hgt_test_ratio: %8.4f\n",(double)container.hgt_test_ratio);
		printf("tas_test_ratio: %8.4f\n",(double)container.tas_test_ratio);
		printf("hagl_test_ratio: %8.4f\n",(double)container.hagl_test_ratio);
		printf("beta_test_ratio: %8.4f\n",(double)container.beta_test_ratio);
		printf("solution_status_flags: %u\n",(unsigned)container.solution_status_flags);
		printf("time_slip: %8.4f\n",(double)container.time_slip);
		printf("pre_flt_fail: %s\n",container.pre_flt_fail ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_obstacle_distance(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(obstacle_distance), topic_instance);
	orb_id_t ID = ORB_ID(obstacle_distance);
	struct obstacle_distance_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: obstacle_distance instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("sensor_type: %u\n",(unsigned)container.sensor_type);
		printf("distances: ");
		for (int j = 0; j < 72; j++) {
			printf("%u ",container.distances[j]);
		}
		printf("\n");
		printf("increment: %u\n",(unsigned)container.increment);
		printf("min_distance: %u\n",(unsigned)container.min_distance);
		printf("max_distance: %u\n",(unsigned)container.max_distance);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_lqr_controls(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(lqr_controls), topic_instance);
	orb_id_t ID = ORB_ID(lqr_controls);
	struct lqr_controls_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: lqr_controls instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("roll_moment: %8.4f\n",(double)container.roll_moment);
		printf("pitch_moment: %8.4f\n",(double)container.pitch_moment);
		printf("yaw_moment: %8.4f\n",(double)container.yaw_moment);
		printf("thrust_moment: %8.4f\n",(double)container.thrust_moment);
		printf("roll_angle: %8.4f\n",(double)container.roll_angle);
		printf("pitch_angle: %8.4f\n",(double)container.pitch_angle);
		printf("yaw_angle: %8.4f\n",(double)container.yaw_angle);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_telemetry_status(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(telemetry_status), topic_instance);
	orb_id_t ID = ORB_ID(telemetry_status);
	struct telemetry_status_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: telemetry_status instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("heartbeat_time: %" PRIu64 "\n",container.heartbeat_time);
		printf("telem_time: %" PRIu64 "\n",container.telem_time);
		printf("type: %u\n",(unsigned)container.type);
		printf("rssi: %u\n",(unsigned)container.rssi);
		printf("remote_rssi: %u\n",(unsigned)container.remote_rssi);
		printf("rxerrors: %u\n",(unsigned)container.rxerrors);
		printf("fixed: %u\n",(unsigned)container.fixed);
		printf("noise: %u\n",(unsigned)container.noise);
		printf("remote_noise: %u\n",(unsigned)container.remote_noise);
		printf("txbuf: %u\n",(unsigned)container.txbuf);
		printf("system_id: %u\n",(unsigned)container.system_id);
		printf("component_id: %u\n",(unsigned)container.component_id);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_irlock_report(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(irlock_report), topic_instance);
	orb_id_t ID = ORB_ID(irlock_report);
	struct irlock_report_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: irlock_report instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("signature: %u\n",(unsigned)container.signature);
		printf("pos_x: %8.4f\n",(double)container.pos_x);
		printf("pos_y: %8.4f\n",(double)container.pos_y);
		printf("size_x: %8.4f\n",(double)container.size_x);
		printf("size_y: %8.4f\n",(double)container.size_y);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_mag(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_mag), topic_instance);
	orb_id_t ID = ORB_ID(sensor_mag);
	struct sensor_mag_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_mag instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("error_count: %" PRIu64 "\n",container.error_count);
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("range_ga: %8.4f\n",(double)container.range_ga);
		printf("scaling: %8.4f\n",(double)container.scaling);
		printf("temperature: %8.4f\n",(double)container.temperature);
		printf("x_raw: %d\n",(int)container.x_raw);
		printf("y_raw: %d\n",(int)container.y_raw);
		printf("z_raw: %d\n",(int)container.z_raw);
		printf("device_id: %u\n",container.device_id);
		printf("is_external: %s\n",container.is_external ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_uavcan_parameter_request(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(uavcan_parameter_request), topic_instance);
	orb_id_t ID = ORB_ID(uavcan_parameter_request);
	struct uavcan_parameter_request_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: uavcan_parameter_request instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("message_type: %u\n",(unsigned)container.message_type);
		printf("node_id: %u\n",(unsigned)container.node_id);
		printf("param_index: %d\n",(int)container.param_index);
		printf("param_type: %u\n",(unsigned)container.param_type);
		printf("int_value: %" PRId64 "\n",container.int_value);
		printf("real_value: %8.4f\n",(double)container.real_value);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_land_detected(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_land_detected), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_land_detected);
	struct vehicle_land_detected_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_land_detected instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("landed: %s\n",container.landed ? "True" : "False");
		printf("freefall: %s\n",container.freefall ? "True" : "False");
		printf("ground_contact: %s\n",container.ground_contact ? "True" : "False");
		printf("maybe_landed: %s\n",container.maybe_landed ? "True" : "False");
		printf("alt_max: %8.4f\n",(double)container.alt_max);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_selection(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_selection), topic_instance);
	orb_id_t ID = ORB_ID(sensor_selection);
	struct sensor_selection_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_selection instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("accel_device_id: %u\n",container.accel_device_id);
		printf("baro_device_id: %u\n",container.baro_device_id);
		printf("gyro_device_id: %u\n",container.gyro_device_id);
		printf("mag_device_id: %u\n",container.mag_device_id);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_baro(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_baro), topic_instance);
	orb_id_t ID = ORB_ID(sensor_baro);
	struct sensor_baro_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_baro instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("pressure: %8.4f\n",(double)container.pressure);
		printf("altitude: %8.4f\n",(double)container.altitude);
		printf("temperature: %8.4f\n",(double)container.temperature);
		printf("error_count: %" PRIu64 "\n",container.error_count);
		printf("device_id: %u\n",container.device_id);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_satellite_info(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(satellite_info), topic_instance);
	orb_id_t ID = ORB_ID(satellite_info);
	struct satellite_info_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: satellite_info instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("count: %u\n",(unsigned)container.count);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_task_stack_info(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(task_stack_info), topic_instance);
	orb_id_t ID = ORB_ID(task_stack_info);
	struct task_stack_info_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: task_stack_info instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("stack_free: %u\n",(unsigned)container.stack_free);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_gyro(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_gyro), topic_instance);
	orb_id_t ID = ORB_ID(sensor_gyro);
	struct sensor_gyro_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_gyro instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("integral_dt: %" PRIu64 "\n",container.integral_dt);
		printf("error_count: %" PRIu64 "\n",container.error_count);
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("x_integral: %8.4f\n",(double)container.x_integral);
		printf("y_integral: %8.4f\n",(double)container.y_integral);
		printf("z_integral: %8.4f\n",(double)container.z_integral);
		printf("temperature: %8.4f\n",(double)container.temperature);
		printf("range_rad_s: %8.4f\n",(double)container.range_rad_s);
		printf("scaling: %8.4f\n",(double)container.scaling);
		printf("x_raw: %d\n",(int)container.x_raw);
		printf("y_raw: %d\n",(int)container.y_raw);
		printf("z_raw: %d\n",(int)container.z_raw);
		printf("temperature_raw: %d\n",(int)container.temperature_raw);
		printf("device_id: %u\n",container.device_id);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_local_position(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_local_position), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_local_position);
	struct vehicle_local_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_local_position instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("xy_valid: %s\n",container.xy_valid ? "True" : "False");
		printf("z_valid: %s\n",container.z_valid ? "True" : "False");
		printf("v_xy_valid: %s\n",container.v_xy_valid ? "True" : "False");
		printf("v_z_valid: %s\n",container.v_z_valid ? "True" : "False");
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("delta_xy: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.delta_xy[j]);
		}
		printf("\n");
		printf("xy_reset_counter: %u\n",(unsigned)container.xy_reset_counter);
		printf("delta_z: %8.4f\n",(double)container.delta_z);
		printf("z_reset_counter: %u\n",(unsigned)container.z_reset_counter);
		printf("vx: %8.4f\n",(double)container.vx);
		printf("vy: %8.4f\n",(double)container.vy);
		printf("vz: %8.4f\n",(double)container.vz);
		printf("z_deriv: %8.4f\n",(double)container.z_deriv);
		printf("delta_vxy: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.delta_vxy[j]);
		}
		printf("\n");
		printf("vxy_reset_counter: %u\n",(unsigned)container.vxy_reset_counter);
		printf("delta_vz: %8.4f\n",(double)container.delta_vz);
		printf("vz_reset_counter: %u\n",(unsigned)container.vz_reset_counter);
		printf("ax: %8.4f\n",(double)container.ax);
		printf("ay: %8.4f\n",(double)container.ay);
		printf("az: %8.4f\n",(double)container.az);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("xy_global: %s\n",container.xy_global ? "True" : "False");
		printf("z_global: %s\n",container.z_global ? "True" : "False");
		printf("ref_timestamp: %" PRIu64 "\n",container.ref_timestamp);
		printf("ref_lat: %8.4f\n",(double)container.ref_lat);
		printf("ref_lon: %8.4f\n",(double)container.ref_lon);
		printf("ref_alt: %8.4f\n",(double)container.ref_alt);
		printf("dist_bottom: %8.4f\n",(double)container.dist_bottom);
		printf("dist_bottom_rate: %8.4f\n",(double)container.dist_bottom_rate);
		printf("dist_bottom_valid: %s\n",container.dist_bottom_valid ? "True" : "False");
		printf("eph: %8.4f\n",(double)container.eph);
		printf("epv: %8.4f\n",(double)container.epv);
		printf("evh: %8.4f\n",(double)container.evh);
		printf("evv: %8.4f\n",(double)container.evv);
		printf("vxy_max: %8.4f\n",(double)container.vxy_max);
		printf("limit_hagl: %s\n",container.limit_hagl ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_local_position_groundtruth(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_local_position_groundtruth), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_local_position_groundtruth);
	struct vehicle_local_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_local_position_groundtruth instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("xy_valid: %s\n",container.xy_valid ? "True" : "False");
		printf("z_valid: %s\n",container.z_valid ? "True" : "False");
		printf("v_xy_valid: %s\n",container.v_xy_valid ? "True" : "False");
		printf("v_z_valid: %s\n",container.v_z_valid ? "True" : "False");
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("delta_xy: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.delta_xy[j]);
		}
		printf("\n");
		printf("xy_reset_counter: %u\n",(unsigned)container.xy_reset_counter);
		printf("delta_z: %8.4f\n",(double)container.delta_z);
		printf("z_reset_counter: %u\n",(unsigned)container.z_reset_counter);
		printf("vx: %8.4f\n",(double)container.vx);
		printf("vy: %8.4f\n",(double)container.vy);
		printf("vz: %8.4f\n",(double)container.vz);
		printf("z_deriv: %8.4f\n",(double)container.z_deriv);
		printf("delta_vxy: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.delta_vxy[j]);
		}
		printf("\n");
		printf("vxy_reset_counter: %u\n",(unsigned)container.vxy_reset_counter);
		printf("delta_vz: %8.4f\n",(double)container.delta_vz);
		printf("vz_reset_counter: %u\n",(unsigned)container.vz_reset_counter);
		printf("ax: %8.4f\n",(double)container.ax);
		printf("ay: %8.4f\n",(double)container.ay);
		printf("az: %8.4f\n",(double)container.az);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("xy_global: %s\n",container.xy_global ? "True" : "False");
		printf("z_global: %s\n",container.z_global ? "True" : "False");
		printf("ref_timestamp: %" PRIu64 "\n",container.ref_timestamp);
		printf("ref_lat: %8.4f\n",(double)container.ref_lat);
		printf("ref_lon: %8.4f\n",(double)container.ref_lon);
		printf("ref_alt: %8.4f\n",(double)container.ref_alt);
		printf("dist_bottom: %8.4f\n",(double)container.dist_bottom);
		printf("dist_bottom_rate: %8.4f\n",(double)container.dist_bottom_rate);
		printf("dist_bottom_valid: %s\n",container.dist_bottom_valid ? "True" : "False");
		printf("eph: %8.4f\n",(double)container.eph);
		printf("epv: %8.4f\n",(double)container.epv);
		printf("evh: %8.4f\n",(double)container.evh);
		printf("evv: %8.4f\n",(double)container.evv);
		printf("vxy_max: %8.4f\n",(double)container.vxy_max);
		printf("limit_hagl: %s\n",container.limit_hagl ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_vision_position(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_vision_position), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_vision_position);
	struct vehicle_local_position_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_vision_position instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("xy_valid: %s\n",container.xy_valid ? "True" : "False");
		printf("z_valid: %s\n",container.z_valid ? "True" : "False");
		printf("v_xy_valid: %s\n",container.v_xy_valid ? "True" : "False");
		printf("v_z_valid: %s\n",container.v_z_valid ? "True" : "False");
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("delta_xy: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.delta_xy[j]);
		}
		printf("\n");
		printf("xy_reset_counter: %u\n",(unsigned)container.xy_reset_counter);
		printf("delta_z: %8.4f\n",(double)container.delta_z);
		printf("z_reset_counter: %u\n",(unsigned)container.z_reset_counter);
		printf("vx: %8.4f\n",(double)container.vx);
		printf("vy: %8.4f\n",(double)container.vy);
		printf("vz: %8.4f\n",(double)container.vz);
		printf("z_deriv: %8.4f\n",(double)container.z_deriv);
		printf("delta_vxy: ");
		for (int j = 0; j < 2; j++) {
			printf("%8.4f ",(double)container.delta_vxy[j]);
		}
		printf("\n");
		printf("vxy_reset_counter: %u\n",(unsigned)container.vxy_reset_counter);
		printf("delta_vz: %8.4f\n",(double)container.delta_vz);
		printf("vz_reset_counter: %u\n",(unsigned)container.vz_reset_counter);
		printf("ax: %8.4f\n",(double)container.ax);
		printf("ay: %8.4f\n",(double)container.ay);
		printf("az: %8.4f\n",(double)container.az);
		printf("yaw: %8.4f\n",(double)container.yaw);
		printf("xy_global: %s\n",container.xy_global ? "True" : "False");
		printf("z_global: %s\n",container.z_global ? "True" : "False");
		printf("ref_timestamp: %" PRIu64 "\n",container.ref_timestamp);
		printf("ref_lat: %8.4f\n",(double)container.ref_lat);
		printf("ref_lon: %8.4f\n",(double)container.ref_lon);
		printf("ref_alt: %8.4f\n",(double)container.ref_alt);
		printf("dist_bottom: %8.4f\n",(double)container.dist_bottom);
		printf("dist_bottom_rate: %8.4f\n",(double)container.dist_bottom_rate);
		printf("dist_bottom_valid: %s\n",container.dist_bottom_valid ? "True" : "False");
		printf("eph: %8.4f\n",(double)container.eph);
		printf("epv: %8.4f\n",(double)container.epv);
		printf("evh: %8.4f\n",(double)container.evh);
		printf("evv: %8.4f\n",(double)container.evv);
		printf("vxy_max: %8.4f\n",(double)container.vxy_max);
		printf("limit_hagl: %s\n",container.limit_hagl ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_accel(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(sensor_accel), topic_instance);
	orb_id_t ID = ORB_ID(sensor_accel);
	struct sensor_accel_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: sensor_accel instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("integral_dt: %" PRIu64 "\n",container.integral_dt);
		printf("error_count: %" PRIu64 "\n",container.error_count);
		printf("x: %8.4f\n",(double)container.x);
		printf("y: %8.4f\n",(double)container.y);
		printf("z: %8.4f\n",(double)container.z);
		printf("x_integral: %8.4f\n",(double)container.x_integral);
		printf("y_integral: %8.4f\n",(double)container.y_integral);
		printf("z_integral: %8.4f\n",(double)container.z_integral);
		printf("temperature: %8.4f\n",(double)container.temperature);
		printf("range_m_s2: %8.4f\n",(double)container.range_m_s2);
		printf("scaling: %8.4f\n",(double)container.scaling);
		printf("x_raw: %d\n",(int)container.x_raw);
		printf("y_raw: %d\n",(int)container.y_raw);
		printf("z_raw: %d\n",(int)container.z_raw);
		printf("temperature_raw: %d\n",(int)container.temperature_raw);
		printf("device_id: %u\n",container.device_id);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_camera_trigger(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(camera_trigger), topic_instance);
	orb_id_t ID = ORB_ID(camera_trigger);
	struct camera_trigger_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: camera_trigger instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("timestamp_utc: %" PRIu64 "\n",container.timestamp_utc);
		printf("seq: %u\n",container.seq);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_armed(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(actuator_armed), topic_instance);
	orb_id_t ID = ORB_ID(actuator_armed);
	struct actuator_armed_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: actuator_armed instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("armed_time_ms: %u\n",container.armed_time_ms);
		printf("armed: %s\n",container.armed ? "True" : "False");
		printf("prearmed: %s\n",container.prearmed ? "True" : "False");
		printf("ready_to_arm: %s\n",container.ready_to_arm ? "True" : "False");
		printf("lockdown: %s\n",container.lockdown ? "True" : "False");
		printf("manual_lockdown: %s\n",container.manual_lockdown ? "True" : "False");
		printf("force_failsafe: %s\n",container.force_failsafe ? "True" : "False");
		printf("in_esc_calibration_mode: %s\n",container.in_esc_calibration_mode ? "True" : "False");
		printf("soft_stop: %s\n",container.soft_stop ? "True" : "False");
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_commander_state(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(commander_state), topic_instance);
	orb_id_t ID = ORB_ID(commander_state);
	struct commander_state_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: commander_state instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("main_state: %u\n",(unsigned)container.main_state);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_roi(unsigned num_msgs, unsigned topic_instance) {
	int sub = orb_subscribe_multi(ORB_ID(vehicle_roi), topic_instance);
	orb_id_t ID = ORB_ID(vehicle_roi);
	struct vehicle_roi_s container;
	memset(&container, 0, sizeof(container));
	bool updated;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub,&updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
		start_time = hrt_absolute_time();
		i++;
		printf("\nTOPIC: vehicle_roi instance %d #%d\n", topic_instance, i);
		orb_copy(ID,sub,&container);
		printf("timestamp: %" PRIu64 "\n", container.timestamp);
		printf("mode: %u\n",(unsigned)container.mode);
		printf("mission_seq: %u\n",container.mission_seq);
		printf("target_seq: %u\n",container.target_seq);
		printf("lat: %8.4f\n",(double)container.lat);
		printf("lon: %8.4f\n",(double)container.lon);
		printf("alt: %8.4f\n",(double)container.alt);
		printf("pitchOffset: %8.4f\n",(double)container.pitchOffset);
		printf("rollOffset: %8.4f\n",(double)container.rollOffset);
		printf("yawOffset: %8.4f\n",(double)container.yawOffset);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

